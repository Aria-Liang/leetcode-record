# Day18 BinaryTree 05

## Related Questions:
### [513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/description/)
```
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        List<Integer> level = new ArrayList<>();
        Queue<TreeNode> q1 = new LinkedList<>();

        if (root == null){
            return -1;
        }

        q1.offer(root);

        while (!q1.isEmpty()){
            int len = q1.size();
            level = new ArrayList<>();
            for (int i = 0; i < len; i++){
                TreeNode node = q1.poll();
                level.add(node.val);
                if (node.left != null) q1.offer(node.left);
                if (node.right != null) q1.offer(node.right);
            }
        }

        return level.get(0);
    }
}
```
这题毫无疑问层序遍历很简单，但是可以优化的地方是：不用记录level这个list of integer, 可以直接记录每一个level第一个元素就可以
```
class Solution {

    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int res = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if (i == 0) {
                    res = poll.val;
                }
                if (poll.left != null) {
                    queue.offer(poll.left);
                }
                if (poll.right != null) {
                    queue.offer(poll.right);
                }
            }
        }
        return res;
    }
}
```

第二种方法是递归的做法：思路是找到deep最深的第一个元素
```
```
  
### [112. Path Sum](https://leetcode.com/problems/path-sum/description/)
```
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null){
            return false;
        }

        if (root.left == null && root.right == null){
            return root.val == targetSum;
        }

        boolean left = hasPathSum(root.left, targetSum - root.val);
        boolean right = hasPathSum(root.right, targetSum - root.val);

        return left || right;
    }
}
```

### [113. Path Sum II](https://leetcode.com/problems/path-sum-ii/description/)
```
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        ArrayList<Integer> list = new ArrayList<>();
        helper(result, root, targetSum, list);
        return result;

    }

    private void helper(List<List<Integer>> result, TreeNode root, int targetSum, ArrayList<Integer> list){
        if (root == null){
            return;
        }

        list.add(root.val);

        if (root.left == null && root.right == null){
            if (root.val == targetSum){
               
                result.add(new ArrayList<>(list));
            }
            //return;
        }

        //list.add(root.val);

        helper(result, root.left, targetSum - root.val, list);
        helper(result, root.right, targetSum - root.val, list);
        list.remove(list.size() - 1);
    }
}
```

### [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```
```

### [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```
```
