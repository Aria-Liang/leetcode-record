# Day8 String 01

##  Basic Knowledge about String
- String instantiation:
```
String str = "abc";
is equivalent to:
     char data[] = {'a', 'b', 'c'};
     String str = new String(data);
```

- String Method: 
```
charAt()	// Returns the character at the specified index (position)
contains()	// Checks whether a string contains a sequence of characters
equals()	// Compares two strings. Returns true if the strings are equal, and false if not
equalsIgnoreCase()	// Compares two strings, ignoring case considerations
isEmpty()	 // Checks whether a string is empty or not
length()	// Returns the length of a specified string
split()	// Splits a string into an array of substrings
toLowerCase()	// Converts a string to lower case letters
trim()	// Removes whitespace from both ends of a string
```

- Convert Char to String/ Convert String to Char: 
```
char c='S';  
String s=String.valueOf(c); 

char c='M';    
String s=Character.toString(c);  

for(int i=0; i<s.length();i++){  
        char c = s.charAt(i);  
        System.out.println("char at "+i+" index is: "+c);  
} 

String s1="hello";    
char[] ch=s1.toCharArray();    
for(int i=0;i<ch.length;i++){    
     System.out.println("char at "+i+" index is: "+ch[i]);   
}  
```
- Convert String to arrayList:
```
String s = "a,b,c,d,e,.........";
List<String> myList = new ArrayList<String>(Arrays.asList(s.split(",")));
```
- Convert char[] to string:
```
StringBuilder sb = new StringBuilder();
for (Character c : ch) {
     sb.append(c);
}
String output = sb.toString();
```

## Related Questions:
### [344. Reverse String](https://leetcode.com/problems/reverse-string/description/)
```
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;

        while (left < right){
            char tem = s[right];
            s[right] = s[left];
            s[left] = tem;
            left++;
            right--;
        }
    }
}
```

### [541. Reverse String II](https://leetcode.com/problems/reverse-string-ii/description/)
```
class Solution {
    public String reverseStr(String s, int k) {
        int slow = 0;
        int fast = k - 1;
        char[] ch=s.toCharArray();  

        while (fast < s.length()){
            help(ch, slow, fast);
            slow += 2*k;
            fast += 2*k;
        }

        if (slow < s.length()){
            help(ch, slow, s.length() - 1);
        }

        StringBuilder sb = new StringBuilder();
 
        for (Character c : ch) {
            sb.append(c);
        }
        
        String output = sb.toString();
        return output;
    }

    public void help(char[] s, int start, int end){
        while (start < end){
            char temp = s[end];
            s[end] = s[start];
            s[start] = temp;
            start++;
            end--;
        }
    }
}   
```
##### 思路基本正确，每次前进2k个元素，如果slow存在fast存在则直接进行反转，如果fast不存在，end index等于length - 1;
##### 可以优化： 1. 直接用string进行变化
#####           2. 用char[]但是不需要单独讨论  if (slow < s.length()){help(ch, slow, s.length() - 1)}；

优化版本1：
```
class Solution {
    public String reverseStr(String s, int k) {
        StringBuffer re = new StringBuffer();     //StringBuilder和StringBuffermutable, 但string是immutable,所以后面re.append()
        int length = s.length();
        int start = 0;

        while (start < length){
            int firstK = (start + k > length)? length: start + k;          //这种写法要熟悉
            int secondK = (start + 2*k > length)? length: start + 2*k;

            StringBuffer temp = new StringBuffer();
            temp.append(s.substring(start, firstK));
            re.append(temp.reverse());                                    //可以直接reverse

            if (firstK < secondK){
                re.append(s.substring(firstK, secondK));                  //substring前闭后开
            }
            
            start += 2*k;
        }

        return re.toString();                                            //记得之后要toString();
    }
}
```
