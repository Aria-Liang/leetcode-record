# Day6 BinaryTree 06

## Related Questions:
### [654. Maximum Binary Tree](https://leetcode.com/problems/maximum-binary-tree/description/)
```
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums.length == 0){
            return null;
        }
        return helper(nums, 0, nums.length);
    }

    private TreeNode helper(int[] nums, int start, int end){
        if (end == start){
            return null;
        }
        
        int middleIndex = findMax(nums, start, end);
        TreeNode root = new TreeNode(nums[middleIndex]);
        int leftstart = start;
        int leftend = middleIndex;
        int rightstart = middleIndex + 1;
        int rightend = end;

        root.left = helper(nums, leftstart, leftend);
        root.right = helper(nums, rightstart, rightend);

        return root;

    }

    private int findMax(int[] nums, int start, int end){
        int max_num = Integer.MIN_VALUE;
        int index = -1;

        for (int i = start; i < end; i++){
            if (nums[i] > max_num){
                max_num = nums[i];
                index = i;
            }
        }

        return index;
    }
}
```

### [617. Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees/description/)
```
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 != null && root2 != null){
            TreeNode newRoot = new TreeNode(root1.val + root2.val);
            newRoot.left = mergeTrees(root1.left, root2.left);
            newRoot.right = mergeTrees(root1.right, root2.right);
            return newRoot;
        }

        else if (root1 != null && root2 == null){
            TreeNode newRoot = new TreeNode(root1.val);
            newRoot.left = mergeTrees(root1.left, null);
            newRoot.right = mergeTrees(root1.right, null);
            return newRoot;
        }

        else if (root2 != null && root1 == null){
            TreeNode newRoot = new TreeNode(root2.val);
            newRoot.left = mergeTrees(root2.left, null);
            newRoot.right = mergeTrees(root2.right, null);
            return newRoot;
        }

        else{
            return null;
        }
    }
}
```

### [700. Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/description/)
```
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null){
            return null;
        }

        if (root.val > val){
            return searchBST(root.left, val);
        }
        else if(root.val == val){
            return root;
        }
        else{
            return searchBST(root.right, val);
        }
    }
}
```

### [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/description/)
```
class ReturnType{
    boolean balanced;
    int minnum;
    int maxnum;
    public ReturnType(boolean balanced, int minnum, int maxnum){
        this.balanced = balanced;
        this.minnum = minnum;
        this.maxnum = maxnum;
    }
}
class Solution {
    public boolean isValidBST(TreeNode root) {
        ReturnType result = helper(root);
        return result.balanced;
    }

    private ReturnType helper(TreeNode root){
        if (root == null){
            return new ReturnType(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
        }

        if (root.left == null && root.right == null){
            return new ReturnType(true, root.val, root.val);
        }

        ReturnType left = helper(root.left);
        ReturnType right = helper(root.right);

        if (root.left == null){
            if (right.minnum > root.val && right.balanced == true){
                return new ReturnType(true, root.val, right.maxnum);
            }
        }

        if (root.right == null){
            if (left.maxnum < root.val && left.balanced == true){
                return new ReturnType(true, left.minnum, root.val);
            }
        }
        
        if (left.balanced == true && right.balanced == true && left.maxnum < root.val && right.minnum > root.val){
            return new ReturnType(true, left.minnum, right.maxnum);
        }
            
        return new ReturnType(false, -1, -1);
        

    }
}
```
