# Day3 LinkedList01

##  Storage in Memory
Linkedlist elements are stored in non-consecutive memory locations

##  Basic Knowledge about array
- Define an Linkedlist in java: 
```
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```
- LinkedList instantiation:
`LinkedList<String> ll = new LinkedList<String>();`

- LinkedList Delete/Add/search/revise: 
Add/Delete: O(1) 
Search: O(n)
```
l1.add("A");
l1.addLast("B"); //at the beginning of the list
l1.addLast("C"); //at the end of the list

l1.contains(Object o);  // return true if the list contains the specified element;
l1.get(int index);      // return the element at the specific position in the list;
l1.getFirst();
l1.getLast();

l1.indexOf(Object o); // return the index of the first occurance of the specific element, return -1 if not exist

l1.poll() // retrieves and remove the head of the list
l1.remove() //retrieve and remove the head of the list
       
list.size()
```

- LinkedList iteration: 
```
for (int i = 0; i < linkedList.size(); i++) {
     System.out.print(linkedList.get(i) + " ");
}

while也可
```
- Change LinkedList to Array:
```
LinkedList<Integer> list= new LinkedList<Integer>();
Object[] a = list.toArray();
for(Object element : a)
        System.out.print(element+" ");
```

## Related Questions:
### [203. Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/)
```
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        ListNode curr = head;

        while (curr != null){
            ListNode next = curr.next;
            if (curr.val == val){
                prev.next = next;
                curr = next;
            }
            else{
                prev = curr;
                curr = next;
            }
        }

        return dummy.next;
    }
}
```

#### [704. Binary Search](https://leetcode.com/problems/binary-search/):  easy

#### [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/description/): easy 

#### [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/): first find the first position, and then find the last position


### Two Pointer
#### [27. Remove Element](https://leetcode.com/problems/remove-element/description/)

1.暴力解法： 每次发现val就把所有元素统一向前移动一格，同时size - 1
```
class Solution {
    public int removeElement(int[] nums, int val) {
        int size = nums.length;
        for (int i = 0; i < size; i++){
            if (nums[i] == val){
                for (int j = i + 1; j < nums.length; j++){
                    nums[j - 1] = nums[j]; 
                }
                i --;
                size --;
            }
        }
        return size;
    }
}
```
2. Two pointer - 同向指针: 
快指针遍历整个array, 慢指针指向non-val的下一个，快指针遍历一遍之后会把所有non-val值赋给慢指针
```
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;

        for (int fast = 0; fast < nums.length; fast++){
            if (nums[fast] != val){
                nums[slow++] = nums[fast];
            }
        }

        return slow;
    }
}
```

3. Two pointer - 双向指针：
```
class Solution {
    public int removeElement(int[] nums, int val) {
        if (nums.length == 0 || nums == null){
            return 0;
        }

        int left = 0;
        int right = nums.length - 1;

        while (left < right){
            while (nums[left] != val && left < nums.length - 1){
                left ++;
            }
            while (nums[right] == val && right > 0){
                right --;
            }

            if (nums[left] == val && nums[right] != val && left < right){
                nums[left] = nums[right];
                nums[right] = val;
                left += 1;
                right -= 1;
            }
        }

        if (nums[left] != val){
            return left + 1;
        }
        return left;
    }
}
```
